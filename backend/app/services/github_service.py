"""
GitHub service for repository management.
"""
import logging
import base64
from pathlib import Path
from typing import Optional
from github import Github, GithubException, Auth

from app.core.config import settings
from app.core.metrics import track_external_call

logger = logging.getLogger(__name__)


class GitHubService:
    """Service for interacting with GitHub API."""

    def __init__(self):
        if not settings.github_token:
            logger.warning("GitHub token not configured. GitHub integration will not work.")
            self.client = None
            self.org = None
            self.org_name = None
            self.is_org = False
            return

        auth = Auth.Token(settings.github_token)
        self.client = Github(auth=auth, base_url=settings.github_base_url)
        self.org_name = settings.github_org

        try:
            # Try to get organization, fallback to user
            self.org = self.client.get_organization(self.org_name)
            self.is_org = True
            logger.info(f"Using GitHub organization: {self.org_name}")
        except GithubException:
            self.org = self.client.get_user(self.org_name)
            self.is_org = False
            logger.info(f"Using GitHub user: {self.org_name}")

    def create_repository(
        self,
        repo_name: str,
        description: str = "",
        private: bool = False
    ) -> tuple[str, str]:
        """
        Create a new GitHub repository.

        Args:
            repo_name: Name of the repository.
            description: Repository description.
            private: Whether the repository should be private.

        Returns:
            Tuple of (repo_url, clone_url).

        Raises:
            Exception: If repository creation fails.
        """
        if not self.client:
            raise Exception("GitHub is not configured. Please set GITHUB_TOKEN and GITHUB_ORG environment variables.")

        with track_external_call("github", "create_repository"):
            try:
                logger.info(f"Creating GitHub repository: {repo_name}")

                if self.is_org:
                    repo = self.org.create_repo(
                        name=repo_name,
                        description=description,
                        private=private,
                        auto_init=False
                    )
                else:
                    repo = self.client.get_user().create_repo(
                        name=repo_name,
                        description=description,
                        private=private,
                        auto_init=False
                    )

                logger.info(f"Repository created: {repo.html_url}")
                return repo.html_url, repo.clone_url

            except GithubException as e:
                logger.error(f"Failed to create repository: {e}")
                raise Exception(f"GitHub API error: {e.data.get('message', str(e))}")

    def push_files(self, repo_name: str, project_path: Path, branch: str = "main"):
        """
        Push files from local directory to GitHub repository using git commands.

        Args:
            repo_name: Name of the repository.
            project_path: Path to the local project directory.
            branch: Branch name to push to.

        Raises:
            Exception: If push fails.
        """
        if not self.client:
            raise Exception("GitHub is not configured. Please set GITHUB_TOKEN and GITHUB_ORG environment variables.")

        with track_external_call("github", "push_files"):
            try:
                full_repo_name = f"{self.org_name}/{repo_name}"
                repo = self.client.get_repo(full_repo_name)

                logger.info(f"Pushing files to {full_repo_name} using git commands")

                # Use git commands to push all files at once
                import subprocess

                # Build authenticated remote URL
                auth_url = repo.clone_url.replace("https://", f"https://{settings.github_token}@")

                # Initialize git repo in project directory
                git_commands = [
                    ["git", "init"],
                    ["git", "config", "user.name", "IDP Platform"],
                    ["git", "config", "user.email", "idp@platform.local"],
                    ["git", "add", "."],
                    ["git", "commit", "-m", "Initial commit - Generated by IDP Platform"],
                    ["git", "branch", "-M", branch],
                    ["git", "remote", "add", "origin", auth_url],
                    ["git", "push", "-u", "origin", branch]
                ]

                for cmd in git_commands:
                    logger.debug(f"Running: {' '.join(cmd[:3])}...")  # Don't log full command (contains token)
                    result = subprocess.run(
                        cmd,
                        cwd=str(project_path),
                        capture_output=True,
                        text=True,
                        timeout=30
                    )

                    if result.returncode != 0:
                        logger.error(f"Git command failed: {result.stderr}")
                        raise Exception(f"Git command failed: {result.stderr}")

                logger.info(f"Successfully pushed all files to {full_repo_name}")

            except subprocess.TimeoutExpired:
                logger.error("Git push timed out")
                raise Exception("Git push timed out after 30 seconds")
            except Exception as e:
                logger.error(f"Failed to push files: {e}")
                raise Exception(f"Failed to push files to GitHub: {str(e)}")

    def repository_exists(self, repo_name: str) -> bool:
        """
        Check if a repository exists.

        Args:
            repo_name: Name of the repository.

        Returns:
            True if repository exists, False otherwise.
        """
        if not self.client:
            return False

        with track_external_call("github", "repository_exists"):
            try:
                full_repo_name = f"{self.org_name}/{repo_name}"
                self.client.get_repo(full_repo_name)
                return True
            except GithubException:
                return False

    def delete_repository(self, repo_name: str):
        """
        Delete a repository.

        Args:
            repo_name: Name of the repository.
        """
        if not self.client:
            raise Exception("GitHub is not configured. Please set GITHUB_TOKEN and GITHUB_ORG environment variables.")

        with track_external_call("github", "delete_repository"):
            try:
                full_repo_name = f"{self.org_name}/{repo_name}"
                repo = self.client.get_repo(full_repo_name)
                repo.delete()
                logger.info(f"Deleted repository: {full_repo_name}")
            except GithubException as e:
                logger.error(f"Failed to delete repository: {e}")
                raise Exception(f"Failed to delete repository: {e.data.get('message', str(e))}")


# Global instance
github_service = GitHubService()
