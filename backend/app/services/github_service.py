"""
GitHub service for repository management.
"""
import logging
import base64
from pathlib import Path
from typing import Optional
from github import Github, GithubException, Auth

from app.core.config import settings

logger = logging.getLogger(__name__)


class GitHubService:
    """Service for interacting with GitHub API."""

    def __init__(self):
        if not settings.github_token:
            logger.warning("GitHub token not configured. GitHub integration will not work.")
            self.client = None
            self.org = None
            self.org_name = None
            self.is_org = False
            return

        auth = Auth.Token(settings.github_token)
        self.client = Github(auth=auth, base_url=settings.github_base_url)
        self.org_name = settings.github_org

        try:
            # Try to get organization, fallback to user
            self.org = self.client.get_organization(self.org_name)
            self.is_org = True
            logger.info(f"Using GitHub organization: {self.org_name}")
        except GithubException:
            self.org = self.client.get_user(self.org_name)
            self.is_org = False
            logger.info(f"Using GitHub user: {self.org_name}")

    def create_repository(
        self,
        repo_name: str,
        description: str = "",
        private: bool = False
    ) -> tuple[str, str]:
        """
        Create a new GitHub repository.

        Args:
            repo_name: Name of the repository.
            description: Repository description.
            private: Whether the repository should be private.

        Returns:
            Tuple of (repo_url, clone_url).

        Raises:
            Exception: If repository creation fails.
        """
        if not self.client:
            raise Exception("GitHub is not configured. Please set GITHUB_TOKEN and GITHUB_ORG environment variables.")

        try:
            logger.info(f"Creating GitHub repository: {repo_name}")

            if self.is_org:
                repo = self.org.create_repo(
                    name=repo_name,
                    description=description,
                    private=private,
                    auto_init=False
                )
            else:
                repo = self.client.get_user().create_repo(
                    name=repo_name,
                    description=description,
                    private=private,
                    auto_init=False
                )

            logger.info(f"Repository created: {repo.html_url}")
            return repo.html_url, repo.clone_url

        except GithubException as e:
            logger.error(f"Failed to create repository: {e}")
            raise Exception(f"GitHub API error: {e.data.get('message', str(e))}")

    def push_files(self, repo_name: str, project_path: Path, branch: str = "main"):
        """
        Push files from local directory to GitHub repository.

        Args:
            repo_name: Name of the repository.
            project_path: Path to the local project directory.
            branch: Branch name to push to.

        Raises:
            Exception: If push fails.
        """
        if not self.client:
            raise Exception("GitHub is not configured. Please set GITHUB_TOKEN and GITHUB_ORG environment variables.")

        try:
            full_repo_name = f"{self.org_name}/{repo_name}"
            repo = self.client.get_repo(full_repo_name)

            logger.info(f"Pushing files to {full_repo_name}")

            # Collect all files to push
            files_to_push = []
            for file_path in project_path.rglob("*"):
                if file_path.is_file():
                    relative_path = file_path.relative_to(project_path)

                    # Skip __pycache__ and other unwanted files
                    if "__pycache__" in str(relative_path) or str(relative_path).startswith("."):
                        continue

                    with open(file_path, "rb") as f:
                        content = f.read()

                    files_to_push.append({
                        "path": str(relative_path),
                        "content": content
                    })

            # Create initial commit with all files
            # For simplicity, we'll create files one by one (can be optimized with Git tree API)
            commit_message = "Initial commit - Generated by IDP Platform"

            # Create README if not exists
            readme_exists = any(f["path"] == "README.md" for f in files_to_push)
            if not readme_exists:
                readme_content = f"# {repo_name}\n\nGenerated by IDP Platform\n"
                repo.create_file("README.md", commit_message, readme_content, branch=branch)

            # Push all files
            for file_info in files_to_push:
                try:
                    repo.create_file(
                        file_info["path"],
                        f"Add {file_info['path']}",
                        file_info["content"],
                        branch=branch
                    )
                    logger.debug(f"Created file: {file_info['path']}")
                except GithubException as e:
                    # If file exists or other error, log and continue
                    logger.warning(f"Could not create {file_info['path']}: {e}")

            logger.info(f"Successfully pushed {len(files_to_push)} files to {full_repo_name}")

        except GithubException as e:
            logger.error(f"Failed to push files: {e}")
            raise Exception(f"Failed to push files to GitHub: {e.data.get('message', str(e))}")

    def repository_exists(self, repo_name: str) -> bool:
        """
        Check if a repository exists.

        Args:
            repo_name: Name of the repository.

        Returns:
            True if repository exists, False otherwise.
        """
        if not self.client:
            return False

        try:
            full_repo_name = f"{self.org_name}/{repo_name}"
            self.client.get_repo(full_repo_name)
            return True
        except GithubException:
            return False

    def delete_repository(self, repo_name: str):
        """
        Delete a repository.

        Args:
            repo_name: Name of the repository.
        """
        if not self.client:
            raise Exception("GitHub is not configured. Please set GITHUB_TOKEN and GITHUB_ORG environment variables.")

        try:
            full_repo_name = f"{self.org_name}/{repo_name}"
            repo = self.client.get_repo(full_repo_name)
            repo.delete()
            logger.info(f"Deleted repository: {full_repo_name}")
        except GithubException as e:
            logger.error(f"Failed to delete repository: {e}")
            raise Exception(f"Failed to delete repository: {e.data.get('message', str(e))}")


# Global instance
github_service = GitHubService()
